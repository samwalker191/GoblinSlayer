/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./src/assets/images/spritesheet.png":
/*!*******************************************!*\
  !*** ./src/assets/images/spritesheet.png ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__.p + \"53f28aab3e119715acfc5839d22454aa.png\";\n\n//# sourceURL=webpack:///./src/assets/images/spritesheet.png?");

/***/ }),

/***/ "./src/classes/entity.js":
/*!*******************************!*\
  !*** ./src/classes/entity.js ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const Util = __webpack_require__(/*! ../util/game_util */ \"./src/util/game_util.js\");\nconst spriteSheet = __webpack_require__(/*! ../assets/images/spritesheet.png */ \"./src/assets/images/spritesheet.png\");\n\n\nclass Entity {\n    constructor(pos, currentLevel, canvas) {\n        this.pos = pos;\n        this.canvas = canvas\n        this.currentLevel = currentLevel;\n        this.destination = null;\n        this.oldPos = null;\n        this.img = new Image();\n        this.img.src = spriteSheet;\n    }\n\n    validMove(destination) {\n        return this.currentLevel.board[destination.row][destination.col] < 1;\n    }\n}\n\nmodule.exports = Entity;\n\n//# sourceURL=webpack:///./src/classes/entity.js?");

/***/ }),

/***/ "./src/classes/game.js":
/*!*****************************!*\
  !*** ./src/classes/game.js ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const Constants = __webpack_require__(/*! ../util/constants */ \"./src/util/constants.js\");\nconst Util = __webpack_require__(/*! ../util/game_util */ \"./src/util/game_util.js\");\nconst LevelOne = __webpack_require__(/*! ../util/levels/level1 */ \"./src/util/levels/level1.js\");\nconst Player = __webpack_require__(/*! ./player */ \"./src/classes/player.js\");\nconst Goblin = __webpack_require__(/*! ./goblin */ \"./src/classes/goblin.js\");\nconst spriteSheet = __webpack_require__(/*! ../assets/images/spritesheet.png */ \"./src/assets/images/spritesheet.png\");\n\nclass Game {\n    constructor(boardCanvas, animateCanvas, attackCanvas, levels) {\n        this.levels = levels\n        this.kills = 0;\n        this.limit = 1;\n        this.currentLevel = levels[0];\n        this.boardCanvas = boardCanvas;\n        this.animateCanvas = animateCanvas;\n        this.animateCanvas.width = this.currentLevel.tileSize * this.currentLevel.cols;\n        this.animateCanvas.height = this.currentLevel.tileSize * this.currentLevel.rows;\n        this.attackCanvas = attackCanvas;\n        this.attackCanvas.width = this.currentLevel.tileSize * this.currentLevel.cols;\n        this.attackCanvas.height = this.currentLevel.tileSize * this.currentLevel.rows;\n        this.aniCtx = this.animateCanvas.getContext('2d');\n        this.attackCtx = this.attackCanvas.getContext('2d');\n        this.player = new Player({ col: 1, row: 2 }, this.currentLevel, this.animateCanvas, this.attackCanvas);\n        this.goblins = [];\n        this.img = new Image();\n        this.img.src = spriteSheet;\n        ;\n    }    \n\n    allObjects() {\n        return [].concat(this.player).concat(this.goblins);\n    }\n\n    allEnemies() {\n        return [].concat(this.goblins);\n    }\n\n    // resolveCollisions() {\n    //     for (let i = 0; i < this.goblins.length; i++) {\n    //         for (let j = i+1; j < this.goblins.length; j++) {\n    //             if ((this.goblins[i].pos.col === this.goblins[j].pos.col) && (this.goblins[i].pos.row === this.goblins[j].pos.row)) {\n    //                 this.goblins.splice(i, 1);\n    //             }\n    //         }\n    //     }\n    // }\n\n    allOccupiedTiles() {\n        let occupiedTiles = [];\n        occupiedTiles.push(this.player.pos);\n        this.goblins.forEach(goblin => {\n            occupiedTiles.push(goblin.pos);\n        })\n        return occupiedTiles;\n    }\n\n    randomPos() {\n        let pos = { col: Util.randomInt(1, 9), row: Util.randomInt(2, 8) };\n        this.allOccupiedTiles().forEach(tile => {\n            while (pos.col === tile.col && pos.row === tile.row) {\n                pos = { col: Util.randomInt(1, 9), row: Util.randomInt(2, 8) };\n            }\n        })\n        return pos;\n    }\n\n    addGoblins() {\n        while (this.goblins.length < this.limit) {\n            this.goblins.push(new Goblin(this.randomPos(), this.currentLevel, this.animateCanvas, this.player.pos));\n        }\n    }\n    \n    updateBoard() {\n        if (Number.isInteger(this.player.pos.row) && Number.isInteger(this.player.pos.col)) {\n            this.currentLevel.board[this.player.pos.row][this.player.pos.col] = -1;\n        }\n\n        this.goblins.forEach(goblin => {\n            if (Number.isInteger(goblin.pos.row) && Number.isInteger(goblin.pos.col)) {\n                this.currentLevel.board[goblin.pos.row][goblin.pos.col] = -2;\n            }\n        })\n    }\n\n    increaseDifficulty() {\n        this.limit = Math.ceil(this.kills / 2.5);\n    }\n\n    step(timeDelta) {\n        this.aniCtx.clearRect(0, 0, 5000, 5000);\n        if (this.player.state.includes('ATTACK')) {\n            this.player.drawAttack();            \n            this.goblins.forEach((goblin, idx) => {\n                if (this.player.attack(goblin)) {\n                    this.goblins[idx] = '';\n                    this.currentLevel.board[goblin.pos.row][goblin.pos.col] = 0;\n                    this.kills += 1;\n                }\n            })\n            this.goblins = this.goblins.filter(Boolean);\n        }\n        this.allObjects().forEach(obj => {\n            obj.move(timeDelta);\n        })\n        if (this.goblins.length === 0) {\n            this.addGoblins();\n        }\n        this.drawEntities();\n        this.updateBoard();\n        this.increaseDifficulty();\n    }\n\n    bindKeyListeners() {\n        document.addEventListener(\"keydown\", (e) => {\n            switch (e.keyCode) {\n                case 87: // W\n                    if (this.player.state === 'IDLE' && this.goblins.every(goblin => goblin.state === 'IDLE')) {\n                        this.player.state = 'MOVING_UP';\n                        this.player.destination = { col: this.player.pos.col, row: this.player.pos.row - 1 };\n                        this.player.oldPos = { col: this.player.pos.col, row: this.player.pos.row };\n                        this.goblins.forEach(goblin => {\n                            goblin.state = 'MOVING';\n                        });\n                    }\n                    break;\n                case 65: // A\n                    if (this.player.state === 'IDLE' && this.goblins.every(goblin => goblin.state === 'IDLE')) {\n                        this.player.state = 'MOVING_LEFT';\n                        this.player.destination = { col: this.player.pos.col - 1, row: this.player.pos.row }; \n                        this.player.oldPos = { col: this.player.pos.col, row: this.player.pos.row };\n                        this.goblins.forEach(goblin => {\n                            \n                            goblin.state = 'MOVING';\n                        });                    \n                    }\n                    break;\n                case 83: // S\n                    if (this.player.state === 'IDLE' && this.goblins.every(goblin => goblin.state === 'IDLE')) {\n                        this.player.state = 'MOVING_DOWN';\n                        this.player.destination = { col: this.player.pos.col, row: this.player.pos.row + 1 };   \n                        this.player.oldPos = { col: this.player.pos.col, row: this.player.pos.row };\n                        this.goblins.forEach(goblin => {\n                            goblin.state = 'MOVING';\n                        });                    \n                    }\n                    break;\n                case 68: // D\n                    if (this.player.state === 'IDLE' && this.goblins.every(goblin => goblin.state === 'IDLE')) {\n                        this.player.state = 'MOVING_RIGHT';\n                        this.player.destination = { col: this.player.pos.col + 1, row: this.player.pos.row };    \n                        this.player.oldPos = { col: this.player.pos.col, row: this.player.pos.row };\n                        this.goblins.forEach(goblin => {\n                            goblin.state = 'MOVING';\n                        });                    \n                    }\n                    break;\n                case 38: // UpArrow\n                    e.preventDefault();\n                    if (this.player.state === 'IDLE' && this.player.attacking <= 0 && this.goblins.every(goblin => goblin.state === 'IDLE')) {\n                        this.swordAudio();\n                        this.player.state = 'ATTACK_UP';\n                        this.player.attacking = 100;\n                        this.goblins.forEach(goblin => {\n                            goblin.state = 'MOVING';\n                        });                    \n                    }\n                case 37: // LeftArrow\n                    e.preventDefault();\n                    if (this.player.state === 'IDLE' && this.player.attacking <= 0 && this.goblins.every(goblin => goblin.state === 'IDLE')) {\n                        this.swordAudio();\n                        this.player.state = 'ATTACK_LEFT';\n                        this.player.attacking = 100;\n                        this.goblins.forEach(goblin => {\n                            goblin.state = 'MOVING';\n                        });                    \n                    }\n                case 40: // DownArrow\n                    e.preventDefault();\n                    if (this.player.state === 'IDLE' && this.player.attacking <= 0 && this.goblins.every(goblin => goblin.state === 'IDLE')) {\n                        this.swordAudio();\n                        this.player.state = 'ATTACK_DOWN';\n                        this.player.attacking = 100;\n                        this.goblins.forEach(goblin => {\n                            goblin.state = 'MOVING';\n                        });                    \n                    }\n                case 39: // RightArrow\n                    e.preventDefault();\n                    if (this.player.state === 'IDLE' && this.player.attacking <= 0 && this.goblins.every(goblin => goblin.state === 'IDLE')) {\n                        this.swordAudio();                    \n                        this.player.state = 'ATTACK_RIGHT';\n                        this.player.attacking = 100;\n                        this.goblins.forEach(goblin => {\n                            goblin.state = 'MOVING';\n                        });                    \n                    }\n                default:\n                    break;\n            }\n        })\n    }\n\n    drawBoard(level) {\n        // window.onload = () => {\n            level.drawLevel(this.boardCanvas);\n        // }\n    }\n\n    drawEntities() {\n        this.allObjects().forEach(obj => obj.draw(this.currentLevel));\n    }\n\n    swordAudio() { //“Sound effects obtained from https://www.zapsplat.com“\n        let sound = document.getElementById(\"sword-slash\");\n        sound.play();\n    }\n}\n\nmodule.exports = Game\n\n//# sourceURL=webpack:///./src/classes/game.js?");

/***/ }),

/***/ "./src/classes/game_view.js":
/*!**********************************!*\
  !*** ./src/classes/game_view.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("class GameView {\n    constructor(game) {\n        this.game = game;\n    }\n\n    start() {\n        this.game.bindKeyListeners();\n        this.lastTime = 0;\n        this.game.drawBoard(this.game.levels[0]);\n        this.showGame();\n        requestAnimationFrame(this.animate.bind(this));\n    }\n\n    animate(time) {\n        requestAnimationFrame(this.animate.bind(this));\n        const timeDelta = time - this.lastTime;\n        this.game.step(timeDelta);\n        this.lastTime = time;\n    }\n\n    showGame() {\n        const gameContainer = document.getElementsByClassName('game-container')[0];\n        gameContainer.classList.remove('game-container');\n        gameContainer.classList.add('game-container-active');\n        const notGameElements = document.getElementsByClassName('not-game');\n        Array.from(notGameElements).forEach((ele) => ele.classList.add('hidden'));\n    }\n}\n\nmodule.exports = GameView;\n\n//# sourceURL=webpack:///./src/classes/game_view.js?");

/***/ }),

/***/ "./src/classes/goblin.js":
/*!*******************************!*\
  !*** ./src/classes/goblin.js ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const Entity = __webpack_require__(/*! ./entity */ \"./src/classes/entity.js\");\nconst Sprite = __webpack_require__(/*! ../util/sprite_util */ \"./src/util/sprite_util.js\");\nconst findPath = __webpack_require__(/*! ../util/movement_util */ \"./src/util/movement_util.js\");\n\n// goblin_idle_anim 368 32 16 16 4\n// goblin_run_anim 432 32 16 16 4\n\nclass Goblin extends Entity {\n    constructor(pos, currentlevel, canvas, playerPos) {\n        super(pos, currentlevel, canvas);\n        this.playerPos = playerPos;\n        this.size = { w: 64, h: 64 };\n        this.state = 'IDLE';\n        this.goblinSprite = new Sprite({\n            ctx: canvas.getContext('2d'),\n            width: 128 * 4,\n            height: 68,\n            img: this.img,\n            ticksPerFrame: 5,\n            numberOfFrames: 4,\n            loop: true\n        });\n    }\n\n    setMoveDirection() {\n        if (this.state === 'IDLE') {\n            this.destination = findPath(\n                this.currentLevel.board,\n                this.pos,\n                { col: Math.round(this.playerPos.col), row: Math.round(this.playerPos.row) }\n            )[1];\n        } else if (this.state === 'MOVING') {\n            if (this.destination.row === Math.ceil(this.pos.row) - 1) {\n                \n                this.oldPos = { col: Math.floor(this.pos.col), row: Math.floor(this.pos.row) };\n                this.state = 'MOVING_UP';\n            } else if (this.destination.col === this.pos.col - 1) {\n                this.oldPos = { col: Math.floor(this.pos.col), row: Math.floor(this.pos.row) };\n                this.state = 'MOVING_LEFT';\n            } else if (this.destination.row === this.pos.row + 1) {\n                this.oldPos = { col: Math.floor(this.pos.col), row: Math.floor(this.pos.row) };\n                this.state = \"MOVING_DOWN\";\n            } else if (this.destination.col === this.pos.col + 1) {\n                this.oldPos = { col: Math.floor(this.pos.col), row: Math.floor(this.pos.row) };\n                this.state = \"MOVING_RIGHT\";\n            } else {\n                this.state = 'IDLE';\n            }\n        }\n        \n    }\n\n    move(timeDelta) {\n        this.setMoveDirection();\n        if (this.state === 'MOVING_UP') {\n            \n                if (Math.ceil(this.pos.row) === this.destination.row) {\n                    this.pos.row = this.destination.row;\n                    this.currentLevel.board[this.oldPos.row][this.oldPos.col] = 0;\n                    this.state = 'IDLE';\n                    return;\n                } else {\n                    this.pos.row += -2 / timeDelta;\n                }\n        } else if (this.state === 'MOVING_LEFT') {\n            \n                if (Math.ceil(this.pos.col) === this.destination.col) {\n                    this.pos.col = this.destination.col;\n                    this.currentLevel.board[this.oldPos.row][this.oldPos.col] = 0;\n                    this.state = 'IDLE';\n                    return;\n                } else {\n                    this.pos.col += -2 / timeDelta;\n                }\n        } else if (this.state === 'MOVING_DOWN') {\n            \n                if (Math.floor(this.pos.row) === this.destination.row) {\n                    this.pos.row = this.destination.row;\n                    this.currentLevel.board[this.oldPos.row][this.oldPos.col] = 0;\n                    this.state = 'IDLE';\n                    return;\n                } else {\n                    this.pos.row += 2 / timeDelta;\n                }\n        } else if (this.state === 'MOVING_RIGHT') {\n            \n                if (Math.floor(this.pos.col) === this.destination.col) {\n                    this.pos.col = this.destination.col;\n                    this.currentLevel.board[this.oldPos.row][this.oldPos.col] = 0;\n                    this.state = 'IDLE';\n                    return;\n                } else {\n                    this.pos.col += 2 / timeDelta;\n                }\n        }\n    }\n\n    draw(level) {\n        \n        // this.canvas.width = level.tileSize * level.cols;\n        // this.canvas.height = level.tileSize * level.rows;\n\n        this.goblinSprite.update();\n        if (this.state === \"IDLE\") {\n            this.goblinSprite.render(\n                this.pos.col,\n                this.pos.row,\n                this.size.w,\n                this.size.h,\n                368,\n                32,\n                16,\n                16,\n                16\n            );\n        } else {\n            this.goblinSprite.render(\n                this.pos.col,\n                this.pos.row,\n                this.size.w,\n                this.size.h,\n                432,\n                32,\n                16,\n                16,\n                16\n            )\n        }\n        // ctx1.drawImage(\n        //     img, 128, 68, 16, 28,\n        //     this.pos.col * Constants.TILE_SIZE,\n        //     this.pos.row * Constants.TILE_SIZE - 64,\n        //     this.size.w,\n        //     this.size.h\n        // )\n\n    }\n}\n\nmodule.exports = Goblin;\n\n\n\n//# sourceURL=webpack:///./src/classes/goblin.js?");

/***/ }),

/***/ "./src/classes/player.js":
/*!*******************************!*\
  !*** ./src/classes/player.js ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const Entity = __webpack_require__(/*! ./entity */ \"./src/classes/entity.js\");\nconst Sprite = __webpack_require__(/*! ../util/sprite_util */ \"./src/util/sprite_util.js\");\nconst AttackSprite = __webpack_require__(/*! ../util/attack_sprite */ \"./src/util/attack_sprite.js\");\nconst Constants = __webpack_require__(/*! ../util/constants */ \"./src/util/constants.js\");\n\nclass Player extends Entity {\n    constructor(pos, currentlevel, canvas, attackCanvas) {\n        super(pos, currentlevel, canvas);\n        this.size = { w: 64, h: 112 };\n        this.oldPos = this.pos;\n        this.state = 'IDLE';\n        this.attacking = 0;\n        this.tileToAttack = null;\n        this.attackCanvas = attackCanvas;\n        this.playerSprite = new Sprite({\n            ctx: canvas.getContext('2d'),\n            img: this.img,\n            ticksPerFrame: 4,\n            numberOfFrames: 4,\n            loop: true\n        });\n        this.attackSprite = new AttackSprite({\n            ctx: this.attackCanvas.getContext('2d'),\n            img: this.img,\n            ticksPerRotate: 0.5,\n            numberOfRotations: 6,\n            rotateDegrees: 45,\n            loop: false\n        });\n    }\n\n    setTileToAttack() {\n        // this.attacking = 4;\n        if (this.state === 'ATTACK_UP') {\n            this.tileToAttack = { col: this.pos.col, row: this.pos.row - 1 };\n        } else if (this.state === 'ATTACK_LEFT') {\n            this.tileToAttack = { col: this.pos.col - 1, row: this.pos.row };\n        } else if (this.state === 'ATTACK_DOWN') {\n            this.tileToAttack = { col: this.pos.col, row: this.pos.row + 1 };\n        } else if (this.state === 'ATTACK_RIGHT') {\n            this.tileToAttack = { col: this.pos.col + 1, row: this.pos.row };\n        } \n    }\n\n    attack(enemy) {\n        this.setTileToAttack();\n        // this.drawAttack();\n        // this.state = 'IDLE';\n        return (enemy.pos.col === this.tileToAttack.col && enemy.pos.row === this.tileToAttack.row);\n    }\n\n    move(timeDelta) {\n        if (this.attacking > 0) {\n            this.attacking -= timeDelta;\n            return;\n        } else if (this.attacking < 0) {\n            this.attacking = 0;\n            this.state = 'IDLE';\n        }\n        if (this.state === 'MOVING_UP') {\n            if (this.validMove(this.destination)) {\n                if (Math.ceil(this.pos.row) === this.destination.row) {\n                    this.pos.row = this.destination.row;\n                    this.currentLevel.board[this.oldPos.col][this.oldPos.row] = 0;\n                    this.currentLevel.board[this.destination.col][this.destination.row] = -1;\n                    this.state = 'IDLE';\n                    return;\n                } else {\n                    this.pos.row += -2 / timeDelta;\n                }\n            } else {\n                this.state = 'IDLE';\n            }\n        } else if (this.state === 'MOVING_LEFT') {\n            if (this.validMove(this.destination)) {\n                if (Math.ceil(this.pos.col) === this.destination.col) {\n                    this.pos.col = this.destination.col;\n                    this.currentLevel.board[this.oldPos.row][this.oldPos.col] = 0;\n                    this.currentLevel.board[this.destination.row][this.destination.col] = -1;\n                    this.state = 'IDLE';\n                    return;\n                } else {\n                    this.pos.col += -2 / timeDelta;\n                }\n            } else {\n                this.state = 'IDLE';\n            }\n        } else if (this.state === 'MOVING_DOWN') {\n            if (this.validMove(this.destination)) {\n                if (Math.floor(this.pos.row) === this.destination.row) {\n                    this.pos.row = this.destination.row;\n                    this.currentLevel.board[this.oldPos.row][this.oldPos.col] = 0;\n                    this.currentLevel.board[this.destination.row][this.destination.col] = -1;\n                    this.state = 'IDLE';\n                    return;\n                } else {\n                    this.pos.row += 2 / timeDelta;\n                }\n            } else {\n                this.state = 'IDLE';\n            }\n        } else if (this.state === 'MOVING_RIGHT') {\n            if (this.validMove(this.destination)) {\n                if (Math.floor(this.pos.col) === this.destination.col) {\n                    this.pos.col = this.destination.col;\n                    this.currentLevel.board[this.oldPos.row][this.oldPos.col] = 0;\n                    this.currentLevel.board[this.destination.row][this.destination.col] = -1;\n                    this.state = 'IDLE';\n                    return;\n                } else {\n                    this.pos.col += 2 / timeDelta;\n                }\n            } else {\n                this.state = 'IDLE';\n            }\n        }\n    }\n\n    draw() {\n        this.playerSprite.update();\n        if (this.state === \"IDLE\") {\n            this.playerSprite.render(\n                this.pos.col,\n                this.pos.row,\n                this.size.w,\n                this.size.h,\n                128,\n                68,\n                16,\n                28,\n                64\n            );\n        } else if (this.state.includes('MOVING')) {\n            this.playerSprite.render(\n                this.pos.col,\n                this.pos.row,\n                this.size.w,\n                this.size.h,\n                192,\n                68,\n                16,\n                28,\n                64\n            )\n        } else {\n            this.playerSprite.render(\n                this.pos.col,\n                this.pos.row,\n                this.size.w,\n                this.size.h,\n                128,\n                68,\n                16,\n                28,\n                64\n            );\n        }\n    }\n\n    drawAttack() {\n        let ctx = this.attackCanvas.getContext('2d');\n        let offsetX;\n        let offsetY;\n        let rotateBy;\n        if (this.state === 'ATTACK_UP') {\n            this.attackSprite.rotateDegrees = -45;\n            offsetX = -64;\n            offsetY = 0;\n            rotateBy = 11.125;\n        } else if (this.state === 'ATTACK_LEFT') {\n            this.attackSprite.rotateDegrees = 0;\n            offsetX = -64;\n            offsetY = -0;\n            rotateBy = -11.125;\n        } else if (this.state === 'ATTACK_DOWN') {\n            this.attackSprite.rotateDegrees = 90;\n            offsetX = -64;\n            offsetY = 0;\n            rotateBy = 11.125;\n        } else if (this.state === 'ATTACK_RIGHT') {\n            this.attackSprite.rotateDegrees = 0;\n            offsetX = -64;\n            offsetY = 0;\n            rotateBy = 11.125;\n        }\n        this.attackSprite.update();\n        this.attackSprite.render(\n            this.pos.col, // col\n            this.pos.row, // row\n            40, // width\n            84, // height\n            323, // sheetPosX\n            26, // sheetPosY\n            10, // spriteSizeW\n            21, // spriteSizeH\n            offsetX,\n            offsetY,\n            rotateBy\n        );\n        if (this.attacking <= 0) {\n            this.attackSprite.frameIndex = 0;\n            ctx.clearRect(0, 0, 5000, 5000);\n        }\n    }\n}\n\nmodule.exports = Player;\n\n//# sourceURL=webpack:///./src/classes/player.js?");

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const Game = __webpack_require__(/*! ./classes/game */ \"./src/classes/game.js\");\nconst LevelOne = __webpack_require__(/*! ./util/levels/level1 */ \"./src/util/levels/level1.js\");\nconst GameView = __webpack_require__(/*! ./classes/game_view */ \"./src/classes/game_view.js\");\nconst whichTransitionEvent = __webpack_require__(/*! ./util/transition_detect_util */ \"./src/util/transition_detect_util.js\");\n\n\n\ndocument.addEventListener(\"DOMContentLoaded\", () => {\n    const boardCanvas = document.getElementById('board-canvas');\n    const animateCanvas = document.getElementById('animate-canvas');\n    const attackCanvas = document.getElementById('attack-canvas');\n    const level1 = new LevelOne();\n    let levels = [level1];\n    const game = new Game(boardCanvas, animateCanvas, attackCanvas, levels);\n    const gameView = new GameView(game)\n\n    const startButton = document.getElementById('start-btn');\n    startButton.addEventListener('click', () => {\n        gameView.start();\n    })\n\n    const instructionsButton = document.getElementById('instructions-btn');\n    const instructions = document.getElementsByClassName('instructions')[0];\n    const menu = document.getElementsByTagName('ul')[0];\n    const goBackButton = document.getElementsByTagName('button')[0];\n    let transitionEvent;\n\n    const transitionFunc = () => {\n        menu.classList.remove('hidden');\n    }\n\n    instructionsButton.addEventListener('click', () => {\n        menu.classList.add('hidden');\n        instructions.classList.remove('animate-expand');\n        goBackButton.classList.remove('animate-expand');\n        if (transitionEvent) {\n            instructions.removeEventListener(transitionEvent, transitionFunc);\n        }\n    })\n\n    goBackButton.addEventListener('click', () => {\n        instructions.classList.add('animate-expand');\n        goBackButton.classList.add('animate-expand');\n        transitionEvent = whichTransitionEvent();\n\n        if (transitionEvent) {\n            instructions.addEventListener(transitionEvent, transitionFunc);\n        }\n    })\n\n    setTimeout(() => {\n        const header = document.getElementsByTagName('header')[0];\n        header.classList.add('active');\n        \n    }, 400);\n});\n\n//# sourceURL=webpack:///./src/index.js?");

/***/ }),

/***/ "./src/util/attack_sprite.js":
/*!***********************************!*\
  !*** ./src/util/attack_sprite.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const Constants = __webpack_require__(/*! ./constants */ \"./src/util/constants.js\");\n\nclass AttackSprite {\n    constructor(options) {\n        this.ctx = options.ctx;\n        this.img = options.img;\n        this.frameIndex = 0;\n        this.tickCount = 0;\n        this.ticksPerRotate = options.ticksPerRotate || 0;\n        this.numberOfRotations = options.numberOfRotations || 1;\n        this.rotateDegrees = options.rotateDegrees;\n        this.startDegrees = options.rotateDegrees;\n        this.loop = options.loop;\n    }\n\n    update() {\n        this.tickCount += 1;\n        if (this.tickCount > this.ticksPerRotate) {\n            this.tickCount = 0;\n\n            if (this.frameIndex < this.numberOfRotations - 1) {\n                this.frameIndex += 1;\n            } else if (this.loop) {\n                this.frameIndex = 0;\n            }\n        }\n    }\n\n    render(col, row, width, height, sheetPosX, sheetPosY, spriteSizeW, spriteSizeH, pixelOffSetX, pixelOffSetY, rotateBy) {\n        this.ctx.mozImageSmoothingEnabled = false;\n        this.ctx.webkitImageSmoothingEnabled = false;\n        this.ctx.msImageSmoothingEnabled = false;\n        this.ctx.imageSmoothingEnabled = false;\n            this.ctx.clearRect(0, 0, 5000, 5000);\n            this.ctx.save();\n            this.ctx.translate((col * Constants.TILE_SIZE + 40 / 2), (row * Constants.TILE_SIZE + 84 * .285));\n            this.ctx.rotate((this.rotateDegrees + (rotateBy * this.frameIndex)) * Math.PI / 180);\n            this.ctx.translate(-(col * Constants.TILE_SIZE + 40 / 2),  -(row * Constants.TILE_SIZE + 84 * .285));\n            // this.ctx.fillRect(col * Constants.TILE_SIZE, row * Constants.TILE_SIZE, 40, 84);\n            this.ctx.drawImage(\n                this.img,\n                sheetPosX,\n                sheetPosY,\n                spriteSizeW,\n                spriteSizeH,\n                col * Constants.TILE_SIZE + pixelOffSetY,\n                row * Constants.TILE_SIZE + pixelOffSetX,\n                width,\n                height\n            );\n            this.ctx.restore();\n    }\n}\n\nmodule.exports = AttackSprite;\n\n//# sourceURL=webpack:///./src/util/attack_sprite.js?");

/***/ }),

/***/ "./src/util/constants.js":
/*!*******************************!*\
  !*** ./src/util/constants.js ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports.WIDTH = 1000;\nmodule.exports.HEIGHT = 600;\nmodule.exports.TILE_SIZE = 64;\n\n//# sourceURL=webpack:///./src/util/constants.js?");

/***/ }),

/***/ "./src/util/game_util.js":
/*!*******************************!*\
  !*** ./src/util/game_util.js ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("const Util = {\n\n    randomInt(min, max) {\n        min = Math.ceil(min);\n        max = Math.floor(max);\n        return Math.floor(Math.random() * (max - min + 1)) + min;\n    }\n};\n\nmodule.exports = Util;\n\n//# sourceURL=webpack:///./src/util/game_util.js?");

/***/ }),

/***/ "./src/util/levels/level1.js":
/*!***********************************!*\
  !*** ./src/util/levels/level1.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const spriteSheet = __webpack_require__(/*! ../../assets/images/spritesheet.png */ \"./src/assets/images/spritesheet.png\");\nconst Constants = __webpack_require__(/*! ../constants */ \"./src/util/constants.js\");\n\nclass LevelOne {\n    constructor() {\n        this.rows = 11;\n        this.cols = 11;\n        this.tileSize = Constants.TILE_SIZE;\n\n        this.board = [\n            [7, 6, 6, 6, 6, 6, 6, 6, 6, 6, 8],\n            [5, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3],\n            [4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3],\n            [4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3],\n            [4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3],\n            [4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3],\n            [4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3],\n            [4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3],\n            [4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3],\n            [12, 2, 2, 2, 2, 2, 2, 2, 2, 2, 14],\n            [13, 11, 11, 11, 11, 11, 11, 11, 11, 11, 15]\n        ];\n    }\n    drawLevel(canvas) {\n        let img = new Image();\n        img.src = spriteSheet;\n        let ctx = canvas.getContext('2d');\n        canvas.width = this.tileSize * this.cols;\n        canvas.height = this.tileSize * this.rows;\n        ctx.mozImageSmoothingEnabled = false;\n        ctx.webkitImageSmoothingEnabled = false;\n        ctx.msImageSmoothingEnabled = false;\n        ctx.imageSmoothingEnabled = false;\n        // ctx.clearRect(0, 0, canvas.width, canvas.height);\n        \n        for (let i = 0; i < this.rows; i++) {\n            for (let j = 0; j < this.cols; j++) {\n                switch (this.board[i][j]) {\n                    case 0:\n                        ctx.drawImage(\n                            img, 16, 64, 16, 16,\n                            j * this.tileSize, // canvas x\n                            i * this.tileSize, // canvas y\n                            this.tileSize, //canvas width\n                            this.tileSize //canvas height\n                        );\n                        break;\n                    case -1:\n                        ctx.drawImage(\n                            img, 16, 64, 16, 16,\n                            j * this.tileSize, // canvas x\n                            i * this.tileSize, // canvas y\n                            this.tileSize, //canvas width\n                            this.tileSize //canvas height\n                        );\n                        break;\n                    case -2:\n                        ctx.drawImage(\n                            img, 16, 64, 16, 16,\n                            j * this.tileSize, // canvas x\n                            i * this.tileSize, // canvas y\n                            this.tileSize, //canvas width\n                            this.tileSize //canvas height\n                        );\n                        break;\n                    case 1:\n                        ctx.drawImage(\n                            img,\n                            32, //src x\n                            16, //src y\n                            16, //src width\n                            16, //src height\n                            j * this.tileSize, // canvas x\n                            i * this.tileSize, // canvas y\n                            this.tileSize, //canvas width\n                            this.tileSize //canvas height\n                        );\n                        break;\n                    case 2:\n                        ctx.drawImage(\n                            img,\n                            96, //src x\n                            160, //src y\n                            16, //src width\n                            16, //src height\n                            j * this.tileSize, // canvas x\n                            i * this.tileSize, // canvas y\n                            this.tileSize, //canvas width\n                            this.tileSize //canvas height\n                        );\n                        break;\n                    case 3:\n                        ctx.drawImage(\n                            img,\n                            16, //src x\n                            128, //src y\n                            16, //src width\n                            16, //src height\n                            j * this.tileSize, // canvas x\n                            i * this.tileSize, // canvas y\n                            this.tileSize, //canvas width\n                            this.tileSize //canvas height\n                        );\n                        break;\n                    case 4:\n                        ctx.drawImage(\n                            img,\n                            0, //src x\n                            128, //src y\n                            16, //src width\n                            16, //src height\n                            j * this.tileSize, // canvas x\n                            i * this.tileSize, // canvas y\n                            this.tileSize, //canvas width\n                            this.tileSize //canvas height\n                        );\n                        break;\n                    case 5:\n                        ctx.drawImage(\n                            img,\n                            0, //src x\n                            128, //src y\n                            16, //src width\n                            16, //src height\n                            j * this.tileSize, // canvas x\n                            i * this.tileSize, // canvas y\n                            this.tileSize, //canvas width\n                            this.tileSize //canvas height\n                        );\n                        break;\n                    case 6:\n                        ctx.drawImage(\n                            img,\n                            32, //src x\n                            0, //src y\n                            16, //src width\n                            16, //src height\n                            j * this.tileSize, // canvas x\n                            i * this.tileSize, // canvas y\n                            this.tileSize, //canvas width\n                            this.tileSize //canvas height\n                        );\n                        break;\n                    case 7:\n                        ctx.drawImage(\n                            img,\n                            0, //src x\n                            112, //src y\n                            16, //src width\n                            16, //src height\n                            j * this.tileSize, // canvas x\n                            i * this.tileSize, // canvas y\n                            this.tileSize, //canvas width\n                            this.tileSize //canvas height\n                        );\n                        break;\n                    case 8:\n                        ctx.drawImage(\n                            img,\n                            16, //src x\n                            112, //src y\n                            16, //src width\n                            16, //src height\n                            j * this.tileSize, // canvas x\n                            i * this.tileSize, // canvas y\n                            this.tileSize, //canvas width\n                            this.tileSize //canvas height\n                        );\n                        break;\n                    case 9:\n                        ctx.drawImage(\n                            img,\n                            32, //src x\n                            144, //src y\n                            16, //src width\n                            16, //src height\n                            j * this.tileSize, // canvas x\n                            i * this.tileSize, // canvas y\n                            this.tileSize, //canvas width\n                            this.tileSize //canvas height\n                        );\n                        break;\n                    case 10:\n                        ctx.drawImage(\n                            img,\n                            16, //src x\n                            112, //src y\n                            16, //src width\n                            16, //src height\n                            j * this.tileSize, // canvas x\n                            i * this.tileSize, // canvas y\n                            this.tileSize, //canvas width\n                            this.tileSize //canvas height\n                        );\n                        break;\n                    case 11:\n                        ctx.drawImage(\n                            img,\n                            96, //src x\n                            176, //src y\n                            16, //src width\n                            16, //src height\n                            j * this.tileSize, // canvas x\n                            i * this.tileSize, // canvas y\n                            this.tileSize, //canvas width\n                            this.tileSize //canvas height\n                        );\n                        break;\n                    case 12:\n                        ctx.drawImage(\n                            img,\n                            112, //src x\n                            160, //src y\n                            16, //src width\n                            16, //src height\n                            j * this.tileSize, // canvas x\n                            i * this.tileSize, // canvas y\n                            this.tileSize, //canvas width\n                            this.tileSize //canvas height\n                        );\n                        break;\n                    case 13:\n                        ctx.drawImage(\n                            img,\n                            112, //src x\n                            176, //src y\n                            16, //src width\n                            16, //src height\n                            j * this.tileSize, // canvas x\n                            i * this.tileSize, // canvas y\n                            this.tileSize, //canvas width\n                            this.tileSize //canvas height\n                        );\n                        break;\n                    case 14:\n                        ctx.drawImage(\n                            img,\n                            112, //src x\n                            128, //src y\n                            16, //src width\n                            16, //src height\n                            j * this.tileSize, // canvas x\n                            i * this.tileSize, // canvas y\n                            this.tileSize, //canvas width\n                            this.tileSize //canvas height\n                        );\n                        break;\n                    case 15:\n                        ctx.drawImage(\n                            img,\n                            112, //src x\n                            144, //src y\n                            16, //src width\n                            16, //src height\n                            j * this.tileSize, // canvas x\n                            i * this.tileSize, // canvas y\n                            this.tileSize, //canvas width\n                            this.tileSize //canvas height\n                        );\n                        break;\n                    default:\n                        break;\n                }\n            }\n        }\n    }\n}\n\nmodule.exports = LevelOne;\n\n//# sourceURL=webpack:///./src/util/levels/level1.js?");

/***/ }),

/***/ "./src/util/movement_util.js":
/*!***********************************!*\
  !*** ./src/util/movement_util.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("const findPath = (board, pathStart, pathEnd) => {\n    \n    let walkableTileValue = 0;\n    let boardWidth = board[0].length;\n    let boardHeight = board.length;\n    let boardSize = boardWidth * boardHeight;\n\n    let findNeighbours = () => {};\n\n    const manhattanDistance = (point, goal) => {\n        return Math.abs(point.col - goal.col) + Math.abs(point.row - goal.row);\n    };\n    let distanceFunction = manhattanDistance;\n\n    const validTile = (col, row) => {\n        return ((board[row] !== null) && (board[row][col] !== null) && ((board[row][col] <= walkableTileValue) && board[row][col] !== -2));\n    };\n\n    const Neighbours = (col, row) => {\n        let up = row - 1;\n        let left = col - 1;\n        let down = row + 1;\n        let right = col + 1;\n        let canMoveUp = up > -1 && validTile(col, up);\n        let canMoveLeft = left > -1 && validTile(left, row);\n        let canMoveDown = down < boardHeight && validTile(col, down);\n        let canMoveRight = right < boardWidth && validTile(right, row);\n        let result = [];\n        if (canMoveUp) {\n            result.push({ col: col, row: up });\n        }\n\n        if (canMoveLeft) {\n            result.push({ col: left, row: row });\n        }\n\n        if (canMoveDown) {\n            result.push({ col: col, row: down });\n        }\n\n        if (canMoveRight) {\n            result.push({ col: right, row: row });\n        }\n        return result;\n    };\n\n    const Node = (parent, point) => {\n        let newNode = {\n            parent: parent,\n            value: point.col + (point.row * boardWidth),\n            col: point.col,\n            row: point.row,\n            costFromStart: 0,\n            costToGoal: 0\n        };\n        return newNode;\n    };\n\n    const calculatePath = () => {\n        \n        let myPathStart = Node(null, { col: pathStart.col, row: pathStart.row });\n        let myPathEnd = Node(null, { col: pathEnd.col, row: pathEnd.row });\n        let aStar = new Array(boardSize);\n        let open = [myPathStart];\n        let closed = [];\n        let result = [];\n        let myNeighbors;\n        let myNode;\n        let myPath;\n        let length;\n        let max;\n        let min;\n        let i;\n        let j;\n        \n        while (length = open.length) {\n            max = boardSize;\n            min = -1;\n            for (i = 0; i < length; i++) {\n                if (open[i].costFromStart < max) {\n                    max = open[i].costFromStart;\n                    min = i;\n                }\n            }\n\n            myNode = open.splice(min, 1)[0];\n\n            if (myNode.value === myPathEnd.value) {\n                myPath = closed[closed.push(myNode) - 1];\n                do {\n                    result.push({ col: myPath.col, row: myPath.row });\n                } while (myPath = myPath.parent);\n                aStar = [];\n                closed = [];\n                open = [];\n                result.reverse();\n            } else {\n                myNeighbors = Neighbours(myNode.col, myNode.row); //array of neighbors\n\n                for(i = 0; i < myNeighbors.length; i++) {\n                    myPath = Node(myNode, myNeighbors[i]);\n                    if (!aStar[myPath.value]) {\n                        myPath.costToGoal = myNode.costToGoal + distanceFunction(myNeighbors[i], myNode);\n                        myPath.costFromStart = myPath.costToGoal + distanceFunction(myNeighbors[i], myPathEnd);\n                        open.push(myPath);\n                        aStar[myPath.value] = true;\n                    }\n                }\n                closed.push(myNode);\n            }\n        }\n        return result;\n    }\n    return calculatePath();\n}\n\nmodule.exports = findPath;\n\n//# sourceURL=webpack:///./src/util/movement_util.js?");

/***/ }),

/***/ "./src/util/sprite_util.js":
/*!*********************************!*\
  !*** ./src/util/sprite_util.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const Constants = __webpack_require__(/*! ./constants */ \"./src/util/constants.js\");\n\nclass Sprite {\n    constructor(options) {\n        this.ctx = options.ctx;\n        this.img = options.img;\n        this.frameIndex = 0;\n        this.tickCount = 0;\n        this.ticksPerFrame = options.ticksPerFrame || 0;\n        this.numberOfFrames = options.numberOfFrames || 1;\n        this.loop = options.loop;\n    }\n\n    update() {\n        this.tickCount += 1;\n        if (this.tickCount > this.ticksPerFrame) {\n            this.tickCount = 0;\n\n            if (this.frameIndex < this.numberOfFrames - 1) {\n                this.frameIndex += 1;\n            } else if (this.loop) {\n                this.frameIndex = 0;\n            }\n        }\n        \n    }\n\n    render(col, row, width, height, sheetPosX, sheetPosY, spriteSizeW, spriteSizeH, pixelOffSet) {\n        this.ctx.mozImageSmoothingEnabled = false;\n        this.ctx.webkitImageSmoothingEnabled = false;\n        this.ctx.msImageSmoothingEnabled = false;\n        this.ctx.imageSmoothingEnabled = false;\n        // this.ctx.clearRect(col, row, width, height)\n        // this.ctx.save();\n        this.ctx.drawImage(\n            this.img,\n            (this.frameIndex * 16) + sheetPosX,\n            sheetPosY,\n            spriteSizeW,\n            spriteSizeH,\n            col * Constants.TILE_SIZE,\n            row * Constants.TILE_SIZE - pixelOffSet,\n            width,\n            height\n        );\n        // this.ctx.restore();\n    }\n}\n\nmodule.exports = Sprite;\n\n//# sourceURL=webpack:///./src/util/sprite_util.js?");

/***/ }),

/***/ "./src/util/transition_detect_util.js":
/*!********************************************!*\
  !*** ./src/util/transition_detect_util.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// code credit goes to David Walsh @ https://davidwalsh.name/css-animation-callback\n\nconst whichTransitionEvent = () => {\n    let t;\n    let el = document.createElement('fakeelement');\n    let transitions = {\n        'transition': 'transitionend',\n        'OTransition': 'oTransitionEnd',\n        'MozTransition': 'transitionend',\n        'WebkitTransition': 'webkitTransitionEnd'\n    }\n\n    for (i in transitions) {\n        if (el.style[i] !== undefined) {\n            return transitions[i];\n        }\n    }\n}\n\nmodule.exports = whichTransitionEvent;\n\n//# sourceURL=webpack:///./src/util/transition_detect_util.js?");

/***/ })

/******/ });